/*
Copyright (c) 2023-2024 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Mozilla Public License Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://mozilla.org/MPL/2.0/


Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provider

import (
	"context"
	"fmt"
	"terraform-provider-objectscale/internal/client"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &NamespaceResource{}
var _ resource.ResourceWithImportState = &NamespaceResource{}

func NewNamespaceResource() resource.Resource {
	return &NamespaceResource{}
}

// NamespaceResource defines the resource implementation.
type NamespaceResource struct {
	client *client.Client
}

func (r *NamespaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_namespace"
}

func (r *NamespaceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "ECS supports access by multiple tenants, where each tenant is defined by a namespace.",
		Description:         "ECS supports access by multiple tenants, where each tenant is defined by a namespace.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Description:         "Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier. Required.",
				MarkdownDescription: "Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier. Required.",
				Required:            true,
			},
			"id": schema.StringAttribute{
				Description:         "Identifier that is generated by ECS when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
				MarkdownDescription: "Identifier that is generated by ECS when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
				Computed:            true,
			},
			"global": schema.BoolAttribute{
				Description:         "Indicates whether the resource is global.",
				MarkdownDescription: "Indicates whether the resource is global.",
				Computed:            true,
			},
			"remote": schema.BoolAttribute{
				Description:         "Indicates whether the resource is remote.",
				MarkdownDescription: "Indicates whether the resource is remote.",
				Computed:            true,
			},
			"link": schema.SingleNestedAttribute{
				Description:         "Hyperlink to the details for this resource.",
				MarkdownDescription: "Hyperlink to the details for this resource.",
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"rel": schema.StringAttribute{
						Description:         "Rel.",
						MarkdownDescription: "Rel.",
						Computed:            true,
					},
					"href": schema.StringAttribute{
						Description:         "Href.",
						MarkdownDescription: "Href.",
						Computed:            true,
					},
				},
			},
			"creation_time": schema.Int64Attribute{
				Description:         "Timestamp that shows when this resource was created in ECS.",
				MarkdownDescription: "Timestamp that shows when this resource was created in ECS.",
				Computed:            true,
			},
			"inactive": schema.BoolAttribute{
				Description:         "Indicates whether the resource is inactive. When a user removes a resource, the resource is put in this state before it is removed from the ECS database.",
				MarkdownDescription: "Indicates whether the resource is inactive. When a user removes a resource, the resource is put in this state before it is removed from the ECS database.",
				Computed:            true,
			},
			"internal": schema.BoolAttribute{
				Description:         "Indicated whether the resource is an internal resource.",
				MarkdownDescription: "Indicated whether the resource is an internal resource.",
				Computed:            true,
			},
			"default_data_services_vpool": schema.StringAttribute{
				Description:         "Default replication group identifier for this tenant when creating buckets. Required. Updatable.",
				MarkdownDescription: "Default replication group identifier for this tenant when creating buckets. Required. Updatable.",
				Required:            true,
			},
			"allowed_vpools_list": schema.ListAttribute{
				Description:         "List of replication group that are allowed access to namespace.",
				MarkdownDescription: "List of replication group that are allowed access to namespace.",
				Computed:            true,
				ElementType:         types.StringType,
			},
			"disallowed_vpools_list": schema.ListAttribute{
				Description:         "List of replication group that are not allowed access to namespace.",
				MarkdownDescription: "List of replication group that are not allowed access to namespace.",
				Computed:            true,
				ElementType:         types.StringType,
			},
			"namespace_admins": schema.StringAttribute{
				Description:         "Comma separated list of namespace admins. Default: ''. Updatable.",
				MarkdownDescription: "Comma separated list of namespace admins. Default: ''. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             stringdefault.StaticString(""),
			},
			"user_mapping": schema.ListNestedAttribute{
				Description:         "User Mapping. Default: []. Updatable.",
				MarkdownDescription: "User Mapping. Default: []. Updatable.",
				Optional:            true,
				Computed:            true,
				Default: listdefault.StaticValue(types.ListValueMust(types.ObjectType{AttrTypes: map[string]attr.Type{
					"domain": types.StringType,
					"groups": types.ListType{ElemType: types.StringType},
					"attributes": types.ListType{ElemType: types.ObjectType{AttrTypes: map[string]attr.Type{
						"key":   types.StringType,
						"value": types.ListType{ElemType: types.StringType},
					}}},
				}}, []attr.Value{})),
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"domain": schema.StringAttribute{
							Description:         "A single-valued attribute indicating the user's IDP domain",
							MarkdownDescription: "A single-valued attribute indicating the user's IDP domain",
							Optional:            true,
							Computed:            true,
						},
						"groups": schema.ListAttribute{
							Description:         "Groups.",
							MarkdownDescription: "Groups.",
							Optional:            true,
							Computed:            true,
							ElementType:         types.StringType,
						},
						"attributes": schema.ListNestedAttribute{
							Description:         "Attributes.",
							MarkdownDescription: "Attributes.",
							Optional:            true,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Description:         "Lookup string for this key-value pair",
										MarkdownDescription: "Lookup string for this key-value pair",
										Optional:            true,
										Computed:            true,
									},
									"value": schema.ListAttribute{
										Description:         "Lookup result for this key-value pair.",
										MarkdownDescription: "Lookup result for this key-value pair.",
										Optional:            true,
										Computed:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
			"is_encryption_enabled": schema.BoolAttribute{
				Description:         "Encryption status of the namesapce. Default: false.",
				MarkdownDescription: "Encryption status of the namesapce. Default: false.",
				Computed:            true,
				Optional:            true,
				Default:             booldefault.StaticBool(false),
			},
			"default_bucket_block_size": schema.Int64Attribute{
				Description:         "Default bucket quota size. Default: -1. Updatable.",
				MarkdownDescription: "Default bucket quota size. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(-1),
			},
			"external_group_admins": schema.StringAttribute{
				Description:         "List of groups from AD Server. Default: ''. Updatable.",
				MarkdownDescription: "List of groups from AD Server. Default: ''. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             stringdefault.StaticString(""),
			},
			"is_stale_allowed": schema.BoolAttribute{
				Description:         "Namespace isStaleAllowed flag. Default: false. Updatable..",
				MarkdownDescription: "Namespace isStaleAllowed flag. Default: false. Updatable..",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(false),
			},
			"is_object_lock_with_ado_allowed": schema.BoolAttribute{
				Description:         "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace. Default: false. Updatable.",
				MarkdownDescription: "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace. Default: false. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(false),
			},
			"is_compliance_enabled": schema.BoolAttribute{
				Description:         "Namespace isComplianceEnabled flag. Default: false.",
				MarkdownDescription: "Namespace isComplianceEnabled flag. Default: false.",
				Optional:            true,
				Computed:            true,
				Default:             booldefault.StaticBool(false),
			},
			"notification_size": schema.Int64Attribute{
				Description:         "Notification Size in GB. Default: -1. Updatable.",
				MarkdownDescription: "Notification Size in GB. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(-1),
			},
			"block_size": schema.Int64Attribute{
				Description:         "Block Size in GB. Default: -1. Updatable.",
				MarkdownDescription: "Block Size in GB. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(-1),
			},
			"notification_size_in_count": schema.Int64Attribute{
				Description:         "Notification Size in Count. Default: -1. Updatable.",
				MarkdownDescription: "Notification Size in Count. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(-1),
			},
			"block_size_in_count": schema.Int64Attribute{
				Description:         "Block Size in Count. Default: -1. Updatable.",
				MarkdownDescription: "Block Size in Count. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(-1),
			},
			"default_audit_delete_expiration": schema.Int64Attribute{
				Description:         "Default bucket audit delete expiration. Updatable.",
				MarkdownDescription: "Default bucket audit delete expiration. Updatable.",
				Optional:            true,
				Computed:            true,
				Default:             int64default.StaticInt64(0),
			},
			"retention_classes": schema.SingleNestedAttribute{
				Description:         "RetentionClasses.",
				MarkdownDescription: "RetentionClasses.",
				Optional:            true,
				Computed:            true,
				Default: objectdefault.StaticValue(
					types.ObjectValueMust(
						map[string]attr.Type{
							"retention_class": types.ListType{ElemType: types.ObjectType{AttrTypes: map[string]attr.Type{
								"name":   types.StringType,
								"period": types.Int64Type,
							}},
							},
						},
						map[string]attr.Value{
							"retention_class": types.ListValueMust(types.ObjectType{AttrTypes: map[string]attr.Type{
								"name":   types.StringType,
								"period": types.Int64Type,
							}}, []attr.Value{}),
						},
					),
				),
				Attributes: map[string]schema.Attribute{
					"retention_class": schema.ListNestedAttribute{
						Description:         "Retention Class.",
						MarkdownDescription: "Retention Class.",
						Required:            true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									Description:         "Name of the retention class.",
									MarkdownDescription: "Name of the retention class.",
									Required:            true,
								},
								"period": schema.Int64Attribute{
									Description:         "Period of the retention class in seconds.",
									MarkdownDescription: "Period of the retention class in seconds.",
									Required:            true,
								},
							},
						},
					},
				},
			},
			"root_user_name": schema.StringAttribute{
				Description:         "root user name.",
				MarkdownDescription: "root user name.",
				Computed:            true,
			},
			"root_user_password": schema.StringAttribute{
				Description:         "root user password.",
				MarkdownDescription: "root user password.",
				Computed:            true,
			},
		},
	}
}

func (r *NamespaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *NamespaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "creating namespace")
	var plan models.NamespaceResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	namespace, err := helper.BuildNamespaceFromPlan(ctx, &plan)
	if err != nil {
		resp.Diagnostics.AddError("Error building namespace from plan", err.Error())
		return
	}

	namespace, err = r.client.ManagementClient.CreateNamespace(namespace)

	if err != nil {
		resp.Diagnostics.AddError("Error creating namespace", err.Error())
		return
	}

	data := models.NamespaceEntity{}
	err = helper.CopyFields(ctx, namespace, &data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error converting created namespace",
			err.Error(),
		)
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NamespaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "reading namespace")
	var data models.NamespaceEntity

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	namespace, err := r.client.ManagementClient.GetNamespace(data.Name.ValueString())

	if err != nil {
		resp.Diagnostics.AddError("Error reading namespace", err.Error())
		return
	}

	err = helper.CopyFields(ctx, namespace, &data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error converting read namespace",
			err.Error(),
		)
		return
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NamespaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Info(ctx, "updating namespace")
	var plan models.NamespaceResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	namespace, err := helper.BuildNamespaceFromPlan(ctx, &plan)
	if err != nil {
		resp.Diagnostics.AddError("Error building namespace from plan", err.Error())
		return
	}
	// To update the Id whose value does not exist in the plan from the state.
	// For the rest of the non-existing fields' value in the plan won't impact the update result,
	// as the update API would check the difference of the local value and remote value internally,
	// it would use the Id to retrieve the remote value,
	// and the non change value won't trigger the update
	// For the update API, it should use the same get API to get the remote value,
	// so just to refer get API definition to make sure all the required fields have the value assigned
	var data models.NamespaceEntity
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	namespace.Id = data.Id.ValueString()

	// To prevent the non-updatable fields from being changed
	if namespace.Name != data.Name.ValueString() ||
		namespace.IsComplianceEnabled != data.IsComplianceEnabled.ValueBool() ||
		namespace.IsEncryptionEnabled != data.IsEncryptionEnabled.ValueBool() {
		resp.Diagnostics.AddError("Error updating namespace", "Fields of `name`, `is_compliance_enabled` and `is_encryption_enabled` are not updatable")
		return
	}

	_, err = r.client.ManagementClient.UpdateNamespace(namespace)
	if err != nil {
		resp.Diagnostics.AddError("Error updating namespace", err.Error())
		return
	}

	namespace, err = r.client.ManagementClient.GetNamespace(namespace.Id)

	if err != nil {
		resp.Diagnostics.AddError("Error reading namespace", err.Error())
		return
	}

	err = helper.CopyFields(ctx, namespace, &data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error converting read namespace",
			err.Error(),
		)
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NamespaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "deleting namespace")
	var data models.NamespaceEntity

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	err := r.client.ManagementClient.DeleteNamespace(data.Id.ValueString())

	if err != nil {
		resp.Diagnostics.AddError(
			"Error deleting namespace",
			err.Error(),
		)
	}
}

func (r *NamespaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Info(ctx, "importing namespace")
	id := req.ID

	namespace, err := r.client.ManagementClient.GetNamespace(id)

	if err != nil {
		resp.Diagnostics.AddError("Error reading namespace", err.Error())
		return
	}

	data := models.NamespaceEntity{}
	err = helper.CopyFields(ctx, namespace, &data)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error converting imported namespace",
			err.Error(),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
